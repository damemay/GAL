const unsigned char pbr_frag[] =
	"#version 330 core\n\nout vec4 out_color;\n\nstruct Material {\n    vec3 albedo;\n    float metallic;"
	"\n    float roughness;\n\n    sampler2D diffuse_tex;\n    sampler2D normal_tex;\n    sampler2D metal"
	"lic_tex;\n    sampler2D roughness_tex;\n    sampler2D ao_tex;\n\n    bool diffuse_tex_exists;\n    b"
	"ool normal_tex_exists;\n    bool metallic_tex_exists;\n    bool roughness_tex_exists;\n    bool ao_t"
	"ex_exists;\n};\n\nstruct Light {\n    vec3 position;\n    vec3 direction;\n\n    vec3 color;\n\n    "
	"bool directional;\n};\n\nstruct Fog {\n    vec3 color;\n    float near;\n    float far;\n};\n\nin ve"
	"c2 uv0;\nin vec3 wpos;\nin vec3 norm;\n\nuniform vec3 camera_position;\nuniform Material material;\n"
	"uniform Light light;\nuniform Fog fog;\n\nfloat lin_depth(float depth) {\n    float z = depth*2.0-1."
	"0;\n    return (2.0*fog.near*fog.far)/(fog.far+fog.near-z*(fog.far-fog.near));\n}\n\nconst float pi "
	"= 3.14159265359;\n\nvec3 fres(float cos_t, vec3 f0) {\n    return f0+(1.0-f0)*pow(clamp(1.0-cos_t,0."
	"0,1.0),5.0);\n}\n\nfloat dist_ggx(vec3 n, vec3 h, float roughness) {\n    float a = roughness*roughn"
	"ess;\n    float a2 = a*a;\n    float ndoth = max(dot(n,h),0.0);\n    float ndoth2 = ndoth*ndoth;\n  "
	"  float num=a2;\n    float denom=(ndoth2*(a2-1.0)+1.0);\n    denom=pi*denom*denom;\n    return num/d"
	"enom;\n}\n\nfloat geom_sch_ggx(float ndotv, float roughness) {\n    float r = (roughness+1.0);\n    "
	"float k = (r*r)/8.0;\n    float num = ndotv;\n    float denom = ndotv*(1.0-k)+k;\n    return num/den"
	"om;\n}\n\nfloat geom_smith(vec3 n, vec3 v, vec3 l, float roughness) {\n    float ndotv = max(dot(n,v"
	"),0.0);\n    float ndotl = max(dot(n,l),0.0);\n    float ggx2 = geom_sch_ggx(ndotv, roughness);\n   "
	" float ggx1 = geom_sch_ggx(ndotl, roughness);\n    return ggx1*ggx2;\n}\n\nvoid main() {\n    if(tex"
	"ture(material.diffuse_tex, uv0).a < 0.1) discard;\n\n    vec3 albedo;\n    float metallic;\n    floa"
	"t roughness;\n    float ao;\n\n    if(material.diffuse_tex_exists) {\n        albedo = pow(texture(m"
	"aterial.diffuse_tex, uv0).rgb, vec3(2.2));\n    } else {\n        albedo = material.albedo;\n    }\n"
	"\n    if(material.metallic_tex_exists) {\n        metallic = texture(material.metallic_tex, uv0).r;\n"
	"    } else {\n        metallic = material.metallic;\n    }\n\n    if(material.roughness_tex_exists) "
	"{\n        roughness = texture(material.roughness_tex, uv0).r;\n    } else {\n        roughness = ma"
	"terial.roughness;\n    }\n\n    if(material.ao_tex_exists) {\n        ao = texture(material.ao_tex, "
	"uv0).r;\n    } else {\n        ao = 1.0f;\n    }\n\n    vec3 normal;\n    if(material.normal_tex_exi"
	"sts) {\n        vec3 tangent = texture(material.normal_tex, uv0).rgb * 2.0 - 1.0;\n        vec3 q1 ="
	" dFdx(wpos);\n        vec3 q2 = dFdy(wpos);\n        vec2 st1 = dFdx(uv0);\n        vec2 st2 = dFdy("
	"uv0);\n        vec3 n = normalize(norm);\n        vec3 t = normalize(q1*st2.t-q2*st1.t);\n        ve"
	"c3 b = -normalize(cross(n,t));\n        mat3 tbn = mat3(t,b,n);\n        normal = normalize(tbn*tang"
	"ent);\n    } else {\n        normal = normalize(norm);\n    }\n    vec3 v = normalize(camera_positio"
	"n - wpos);\n    vec3 f0 = vec3(0.04);\n    f0 = mix(f0, albedo, metallic);\n\n    vec3 lo = vec3(0.0"
	");\n    vec3 l;\n    if(light.directional) {\n        l = normalize(-light.direction);\n    } else {"
	"\n        l = normalize(light.position-wpos);\n    }\n    vec3 h = normalize(v+l);\n    float dist;\n"
	"    if(light.directional) {\n        dist = length(-light.direction);\n    } else {\n        dist = "
	"length(light.position-wpos);\n    }\n    float attent = 1.0/(dist*dist);\n    vec3 rad = light.color"
	"*attent;\n    float ndf = dist_ggx(normal,h,roughness);\n    float g = geom_smith(normal,v,l,roughne"
	"ss);\n    vec3 f = fres(max(dot(h,v),0.0),f0);\n    vec3 ks = f;\n    vec3 kd = vec3(1.0)-ks;\n    k"
	"d *= 1.0-metallic;\n    vec3 num = ndf*g*f;\n    float denom = 4.0*max(dot(normal,v),0.0)*max(dot(no"
	"rmal,l),0.0)+0.0001;\n    vec3 spec = num/denom;\n    float ndotl = max(dot(normal,l),0.0);\n    lo "
	"+= (kd*albedo/pi+spec)*rad*ndotl;\n    vec3 ambient = vec3(0.03)*albedo*ao;\n    vec3 color = ambien"
	"t+lo;\n    color = color/(color+vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));\n\n    float fog"
	"_factor = lin_depth(gl_FragCoord.z)/fog.far;\n    fog_factor = clamp(fog_factor, 0.0, 1.0);\n\n    o"
	"ut_color = mix(vec4(color,1.0), vec4(fog.color,1.0), fog_factor);\n    //out_color = vec4(color, 1.0"
	");\n}\n";
const unsigned int pbr_frag_len = 4236;
