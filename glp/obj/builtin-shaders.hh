#pragma once

#include <shader.hh>
#include <material.hh>

namespace glp {

namespace Object {

constexpr auto static_shader = "#version 330 core\n"
"layout (location = 0) in vec3 position;\n"
"layout (location = 1) in vec3 normal;\n"
"layout (location = 2) in vec2 texcoord0;\n"
"layout (location = 3) in vec4 joints;\n"
"layout (location = 4) in vec4 weights;\n"
"out vec2 uv0;\n"
"out vec3 wpos;\n"
"out vec3 norm;\n"
"uniform mat4 vp;\n"
"uniform mat4 model;\n"
"void main() {\n"
"    uv0 = texcoord0;\n"
"    wpos = vec3(model * vec4(position, 1.0));\n"
"    norm = transpose(inverse(mat3(model)))*normal;\n"
"    gl_Position = vp * vec4(wpos, 1.0);\n"
"}\n";
constexpr auto skinned_shader = "#version 330 core\n"
"layout (location = 0) in vec3 position;\n"
"layout (location = 1) in vec3 normal;\n"
"layout (location = 2) in vec2 texcoord0;\n"
"layout (location = 3) in vec4 joints;\n"
"layout (location = 4) in vec4 weights;\n"
"out vec2 uv0;\n"
"out vec3 wpos;\n"
"out vec3 norm;\n"
"uniform mat4 vp;\n"
"uniform mat4 model;\n"
"uniform mat4 pose[100];\n"
"void main() {\n"
"    mat4 skin = weights.x * pose[int(joints.x)] +\n"
"                weights.y * pose[int(joints.y)] +\n"
"                weights.z * pose[int(joints.z)] +\n"
"                weights.w * pose[int(joints.w)];\n"
"    uv0 = texcoord0;\n"
"    wpos = vec3(model * vec4(position, 1.0));\n"
"    norm = transpose(inverse(mat3(model)))*normal;\n"
"    gl_Position = vp * skin * vec4(wpos, 1.0);\n"
"}\n";
constexpr auto phong_shader = "#version 330 core\n"
"out vec4 color;\n"
"struct Material {\n"
"    vec3 ambient;\n"
"    vec3 diffuse;\n"
"    vec3 specular;\n"
"    float shininess;\n"
"    sampler2D diffuse_tex;\n"
"    sampler2D normal_tex;\n"
"    sampler2D specular_tex;\n"
"    bool diffuse_tex_exists;\n"
"    bool normal_tex_exists;\n"
"    bool specular_tex_exists;\n"
"};\n"
"struct Light {\n"
"    vec3 position;\n"
"    vec3 direction;\n"
"    vec3 ambient;\n"
"    vec3 diffuse;\n"
"    vec3 specular;\n"
"    bool directional;\n"
"    float linear;\n"
"    float quadratic;\n"
"};\n"
"struct Fog {\n"
"    vec3 color;\n"
"    float near;\n"
"    float far;\n"
"};\n"
"in vec2 uv0;\n"
"in vec3 wpos;\n"
"in vec3 norm;\n"
"uniform vec3 camera_position;\n"
"uniform Material material;\n"
"uniform Light light;\n"
"uniform Fog fog;\n"
"float lin_depth(float depth) {\n"
"    float z = depth*2.0-1.0;\n"
"    return (2.0*fog.near*fog.far)/(fog.far+fog.near-z*(fog.far-fog.near));\n"
"}\n"
"void main()\n"
"{\n"
"    if(texture(material.diffuse_tex, uv0).a < 0.1) discard;\n"
"    vec3 ambient;\n"
"    if(material.diffuse_tex_exists) {\n"
"        ambient = light.ambient * texture(material.diffuse_tex, uv0).rgb;\n"
"    } else {\n"
"        ambient = light.ambient * material.ambient;\n"
"    }\n"
"    vec3 normal;\n"
"    if(material.normal_tex_exists) {\n"
"        vec3 tangent = texture(material.normal_tex, uv0).rgb * 2.0 - 1.0;\n"
"        vec3 q1 = dFdx(wpos);\n"
"        vec3 q2 = dFdy(wpos);\n"
"        vec2 st1 = dFdx(uv0);\n"
"        vec2 st2 = dFdy(uv0);\n"
"        vec3 n = normalize(norm);\n"
"        vec3 t = normalize(q1*st2.t-q2*st1.t);\n"
"        vec3 b = -normalize(cross(n,t));\n"
"        mat3 tbn = mat3(t,b,n);\n"
"        normal = normalize(tbn*tangent);\n"
"    } else {\n"
"        normal = normalize(norm);\n"
"    }\n"
"    vec3 light_dir;\n"
"    if(light.directional) {\n"
"        light_dir = normalize(-light.direction);\n"
"    } else {\n"
"        light_dir = normalize(light.position-wpos);\n"
"    }\n"
"    float diff = max(dot(normal, light_dir), 0.0);\n"
"    vec3 diffuse;\n"
"    if(material.diffuse_tex_exists) {\n"
"        diffuse = light.diffuse * diff * texture(material.diffuse_tex, uv0).rgb;\n"
"    } else {\n"
"        diffuse = light.diffuse * (diff * material.diffuse);\n"
"    }\n"
"    vec3 view_dir = normalize(camera_position - wpos);\n"
"    vec3 reflect_dir = reflect(-light_dir, normal);\n"
"    float spec;\n"
"    if(material.shininess > 0) {\n"
"        spec = pow(max(dot(view_dir, reflect_dir), 0.0), material.shininess);\n"
"    } else {\n"
"        spec = pow(max(dot(view_dir, reflect_dir), 0.0), 0);\n"
"    }\n"
"    vec3 specular;\n"
"    if(material.specular_tex_exists) {\n"
"        specular = light.specular * spec * texture(material.specular_tex, uv0).rgb;\n"
"    } else if(material.diffuse_tex_exists) {\n"
"        specular = light.specular * spec * texture(material.diffuse_tex, uv0).rgb;\n"
"    } else {\n"
"        specular = light.specular * (spec * material.specular);\n"
"    }\n"
"    if(!light.directional) {\n"
"        float dist = length(light.position-wpos);\n"
"        float attent = 1.0/(1.0+light.linear*dist+light.quadratic*(dist*dist));\n"
"        ambient *= attent;\n"
"        diffuse *= attent;\n"
"        specular *= attent;\n"
"    }\n"
"    vec3 result = ambient + diffuse + specular;\n"
"    float fog_factor = lin_depth(gl_FragCoord.z)/fog.far;\n"
"    fog_factor = clamp(fog_factor, 0.0, 1.0);\n"
"    color = mix(vec4(result,1.0), vec4(fog.color,1.0), fog_factor);\n"
"}\n";
constexpr auto pbr_shader = "#version 330 core\n"
"out vec4 out_color;\n"
"struct Material {\n"
"    vec3 albedo;\n"
"    float metallic;\n"
"    float roughness;\n"
"    sampler2D diffuse_tex;\n"
"    sampler2D normal_tex;\n"
"    sampler2D metallic_tex;\n"
"    sampler2D roughness_tex;\n"
"    sampler2D ao_tex;\n"
"    bool diffuse_tex_exists;\n"
"    bool normal_tex_exists;\n"
"    bool metallic_tex_exists;\n"
"    bool roughness_tex_exists;\n"
"    bool ao_tex_exists;\n"
"};\n"
"struct Light {\n"
"    vec3 position;\n"
"    vec3 direction;\n"
"    vec3 color;\n"
"    bool directional;\n"
"};\n"
"struct Fog {\n"
"    vec3 color;\n"
"    float near;\n"
"    float far;\n"
"};\n"
"in vec2 uv0;\n"
"in vec3 wpos;\n"
"in vec3 norm;\n"
"uniform vec3 camera_position;\n"
"uniform Material material;\n"
"uniform Light light;\n"
"uniform Fog fog;\n"
"float lin_depth(float depth) {\n"
"    float z = depth*2.0-1.0;\n"
"    return (2.0*fog.near*fog.far)/(fog.far+fog.near-z*(fog.far-fog.near));\n"
"}\n"
"const float pi = 3.14159265359;\n"
"vec3 fres(float cos_t, vec3 f0) {\n"
"    return f0+(1.0-f0)*pow(clamp(1.0-cos_t,0.0,1.0),5.0);\n"
"}\n"
"float dist_ggx(vec3 n, vec3 h, float roughness) {\n"
"    float a = roughness*roughness;\n"
"    float a2 = a*a;\n"
"    float ndoth = max(dot(n,h),0.0);\n"
"    float ndoth2 = ndoth*ndoth;\n"
"    float num=a2;\n"
"    float denom=(ndoth2*(a2-1.0)+1.0);\n"
"    denom=pi*denom*denom;\n"
"    return num/denom;\n"
"}\n"
"float geom_sch_ggx(float ndotv, float roughness) {\n"
"    float r = (roughness+1.0);\n"
"    float k = (r*r)/8.0;\n"
"    float num = ndotv;\n"
"    float denom = ndotv*(1.0-k)+k;\n"
"    return num/denom;\n"
"}\n"
"float geom_smith(vec3 n, vec3 v, vec3 l, float roughness) {\n"
"    float ndotv = max(dot(n,v),0.0);\n"
"    float ndotl = max(dot(n,l),0.0);\n"
"    float ggx2 = geom_sch_ggx(ndotv, roughness);\n"
"    float ggx1 = geom_sch_ggx(ndotl, roughness);\n"
"    return ggx1*ggx2;\n"
"}\n"
"void main() {\n"
"    if(texture(material.diffuse_tex, uv0).a < 0.1) discard;\n"
"    vec3 albedo;\n"
"    float metallic;\n"
"    float roughness;\n"
"    float ao;\n"
"    if(material.diffuse_tex_exists) {\n"
"        albedo = pow(texture(material.diffuse_tex, uv0).rgb, vec3(2.2));\n"
"    } else {\n"
"        albedo = material.albedo;\n"
"    }\n"
"    if(material.metallic_tex_exists) {\n"
"        metallic = texture(material.metallic_tex, uv0).r;\n"
"    } else {\n"
"        metallic = material.metallic;\n"
"    }\n"
"    if(material.roughness_tex_exists) {\n"
"        roughness = texture(material.roughness_tex, uv0).r;\n"
"    } else {\n"
"        roughness = material.roughness;\n"
"    }\n"
"    if(material.ao_tex_exists) {\n"
"        ao = texture(material.ao_tex, uv0).r;\n"
"    } else {\n"
"        ao = 1.0f;\n"
"    }\n"
"    vec3 normal;\n"
"    if(material.normal_tex_exists) {\n"
"        vec3 tangent = texture(material.normal_tex, uv0).rgb * 2.0 - 1.0;\n"
"        vec3 q1 = dFdx(wpos);\n"
"        vec3 q2 = dFdy(wpos);\n"
"        vec2 st1 = dFdx(uv0);\n"
"        vec2 st2 = dFdy(uv0);\n"
"        vec3 n = normalize(norm);\n"
"        vec3 t = normalize(q1*st2.t-q2*st1.t);\n"
"        vec3 b = -normalize(cross(n,t));\n"
"        mat3 tbn = mat3(t,b,n);\n"
"        normal = normalize(tbn*tangent);\n"
"    } else {\n"
"        normal = normalize(norm);\n"
"    }\n"
"    vec3 v = normalize(camera_position - wpos);\n"
"    vec3 f0 = vec3(0.04);\n"
"    f0 = mix(f0, albedo, metallic);\n"
"    vec3 lo = vec3(0.0);\n"
"    vec3 l;\n"
"    if(light.directional) {\n"
"        l = normalize(-light.direction);\n"
"    } else {\n"
"        l = normalize(light.position-wpos);\n"
"    }\n"
"    vec3 h = normalize(v+l);\n"
"    float dist;\n"
"    if(light.directional) {\n"
"        dist = length(-light.direction);\n"
"    } else {\n"
"        dist = length(light.position-wpos);\n"
"    }\n"
"    float attent = 1.0/(dist*dist);\n"
"    vec3 rad = light.color*attent;\n"
"    float ndf = dist_ggx(normal,h,roughness);\n"
"    float g = geom_smith(normal,v,l,roughness);\n"
"    vec3 f = fres(max(dot(h,v),0.0),f0);\n"
"    vec3 ks = f;\n"
"    vec3 kd = vec3(1.0)-ks;\n"
"    kd *= 1.0-metallic;\n"
"    vec3 num = ndf*g*f;\n"
"    float denom = 4.0*max(dot(normal,v),0.0)*max(dot(normal,l),0.0)+0.0001;\n"
"    vec3 spec = num/denom;\n"
"    float ndotl = max(dot(normal,l),0.0);\n"
"    lo += (kd*albedo/pi+spec)*rad*ndotl;\n"
"    vec3 ambient = vec3(0.03)*albedo*ao;\n"
"    vec3 color = ambient+lo;\n"
"    color = color/(color+vec3(1.0));\n"
"    color = pow(color, vec3(1.0/2.2));\n"
"    float fog_factor = lin_depth(gl_FragCoord.z)/fog.far;\n"
"    fog_factor = clamp(fog_factor, 0.0, 1.0);\n"
"    out_color = mix(vec4(color,1.0), vec4(fog.color,1.0), fog_factor);\n"
"}\n";

inline std::pair<Shader*, ShadingType> make_static_phong() { return std::make_pair(new Shader{static_shader, phong_shader, false}, ShadingType::PHONG); }
inline std::pair<Shader*, ShadingType> make_static_pbr() { return std::make_pair(new Shader{static_shader, pbr_shader, false}, ShadingType::PBR); }
inline std::pair<Shader*, ShadingType> make_skinned_phong() { return std::make_pair(new Shader{skinned_shader, phong_shader, false}, ShadingType::PHONG); }
inline std::pair<Shader*, ShadingType> make_skinned_pbr() { return std::make_pair(new Shader{skinned_shader, pbr_shader, false}, ShadingType::PBR); }

}

}
