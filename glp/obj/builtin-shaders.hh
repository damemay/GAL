#pragma once

#include <shader.hh>
#include <material.hh>

namespace glp {

namespace Object {

#ifndef __vita__
constexpr auto static_shader = "#version 330 core\n"
"layout (location = 0) in vec3 position;\n"
"layout (location = 1) in vec3 normal;\n"
"layout (location = 2) in vec2 texcoord0;\n"
"layout (location = 3) in vec4 joints;\n"
"layout (location = 4) in vec4 weights;\n"
"out vec2 uv0;\n"
"out vec3 wpos;\n"
"out vec3 norm;\n"
"uniform mat4 vp;\n"
"uniform mat4 model;\n"
"void main() {\n"
"    uv0 = texcoord0;\n"
"    wpos = vec3(model * vec4(position, 1.0));\n"
"    norm = transpose(inverse(mat3(model)))*normal;\n"
"    gl_Position = vp * vec4(wpos, 1.0);\n"
"}\n";
constexpr auto skinned_shader = "#version 330 core\n"
"layout (location = 0) in vec3 position;\n"
"layout (location = 1) in vec3 normal;\n"
"layout (location = 2) in vec2 texcoord0;\n"
"layout (location = 3) in vec4 joints;\n"
"layout (location = 4) in vec4 weights;\n"
"out vec2 uv0;\n"
"out vec3 wpos;\n"
"out vec3 norm;\n"
"uniform mat4 vp;\n"
"uniform mat4 model;\n"
"uniform mat4 pose[100];\n"
"void main() {\n"
"    mat4 skin = weights.x * pose[int(joints.x)] +\n"
"                weights.y * pose[int(joints.y)] +\n"
"                weights.z * pose[int(joints.z)] +\n"
"                weights.w * pose[int(joints.w)];\n"
"    uv0 = texcoord0;\n"
"    wpos = vec3(model * vec4(position, 1.0));\n"
"    norm = transpose(inverse(mat3(model)))*normal;\n"
"    gl_Position = vp * skin * vec4(wpos, 1.0);\n"
"}\n";
constexpr auto phong_shader = "#version 330 core\n"
"out vec4 color;\n"
"struct Material {\n"
"    vec3 ambient;\n"
"    vec3 diffuse;\n"
"    vec3 specular;\n"
"    float shininess;\n"
"    sampler2D diffuse_tex;\n"
"    sampler2D normal_tex;\n"
"    sampler2D specular_tex;\n"
"    bool diffuse_tex_exists;\n"
"    bool normal_tex_exists;\n"
"    bool specular_tex_exists;\n"
"};\n"
"struct Light {\n"
"    vec3 position;\n"
"    vec3 direction;\n"
"    vec3 ambient;\n"
"    vec3 diffuse;\n"
"    vec3 specular;\n"
"    bool directional;\n"
"    float linear;\n"
"    float quadratic;\n"
"};\n"
"struct Fog {\n"
"    vec3 color;\n"
"    float near;\n"
"    float far;\n"
"};\n"
"in vec2 uv0;\n"
"in vec3 wpos;\n"
"in vec3 norm;\n"
"uniform vec3 camera_position;\n"
"uniform Material material;\n"
"uniform Light light;\n"
"uniform Fog fog;\n"
"float lin_depth(float depth) {\n"
"    float z = depth*2.0-1.0;\n"
"    return (2.0*fog.near*fog.far)/(fog.far+fog.near-z*(fog.far-fog.near));\n"
"}\n"
"void main()\n"
"{\n"
"    if(texture(material.diffuse_tex, uv0).a < 0.1) discard;\n"
"    vec3 ambient;\n"
"    if(material.diffuse_tex_exists) {\n"
"        ambient = light.ambient * texture(material.diffuse_tex, uv0).rgb;\n"
"    } else {\n"
"        ambient = light.ambient * material.ambient;\n"
"    }\n"
"    vec3 normal;\n"
"    if(material.normal_tex_exists) {\n"
"        vec3 tangent = texture(material.normal_tex, uv0).rgb * 2.0 - 1.0;\n"
"        vec3 q1 = dFdx(wpos);\n"
"        vec3 q2 = dFdy(wpos);\n"
"        vec2 st1 = dFdx(uv0);\n"
"        vec2 st2 = dFdy(uv0);\n"
"        vec3 n = normalize(norm);\n"
"        vec3 t = normalize(q1*st2.t-q2*st1.t);\n"
"        vec3 b = -normalize(cross(n,t));\n"
"        mat3 tbn = mat3(t,b,n);\n"
"        normal = normalize(tbn*tangent);\n"
"    } else {\n"
"        normal = normalize(norm);\n"
"    }\n"
"    vec3 light_dir;\n"
"    if(light.directional) {\n"
"        light_dir = normalize(-light.direction);\n"
"    } else {\n"
"        light_dir = normalize(light.position-wpos);\n"
"    }\n"
"    float diff = max(dot(normal, light_dir), 0.0);\n"
"    vec3 diffuse;\n"
"    if(material.diffuse_tex_exists) {\n"
"        diffuse = light.diffuse * diff * texture(material.diffuse_tex, uv0).rgb;\n"
"    } else {\n"
"        diffuse = light.diffuse * (diff * material.diffuse);\n"
"    }\n"
"    vec3 view_dir = normalize(camera_position - wpos);\n"
"    vec3 reflect_dir = reflect(-light_dir, normal);\n"
"    float spec;\n"
"    if(material.shininess > 0) {\n"
"        spec = pow(max(dot(view_dir, reflect_dir), 0.0), material.shininess);\n"
"    } else {\n"
"        spec = pow(max(dot(view_dir, reflect_dir), 0.0), 0);\n"
"    }\n"
"    vec3 specular;\n"
"    if(material.specular_tex_exists) {\n"
"        specular = light.specular * spec * texture(material.specular_tex, uv0).rgb;\n"
"    } else if(material.diffuse_tex_exists) {\n"
"        specular = light.specular * spec * texture(material.diffuse_tex, uv0).rgb;\n"
"    } else {\n"
"        specular = light.specular * (spec * material.specular);\n"
"    }\n"
"    if(!light.directional) {\n"
"        float dist = length(light.position-wpos);\n"
"        float attent = 1.0/(1.0+light.linear*dist+light.quadratic*(dist*dist));\n"
"        ambient *= attent;\n"
"        diffuse *= attent;\n"
"        specular *= attent;\n"
"    }\n"
"    vec3 result = ambient + diffuse + specular;\n"
"    float fog_factor = lin_depth(gl_FragCoord.z)/fog.far;\n"
"    fog_factor = clamp(fog_factor, 0.0, 1.0);\n"
"    color = mix(vec4(result,1.0), vec4(fog.color,1.0), fog_factor);\n"
"}\n";
constexpr auto pbr_shader = "#version 330 core\n"
"out vec4 out_color;\n"
"struct Material {\n"
"    vec3 albedo;\n"
"    float metallic;\n"
"    float roughness;\n"
"    sampler2D diffuse_tex;\n"
"    sampler2D normal_tex;\n"
"    sampler2D metallic_tex;\n"
"    sampler2D roughness_tex;\n"
"    sampler2D ao_tex;\n"
"    bool diffuse_tex_exists;\n"
"    bool normal_tex_exists;\n"
"    bool metallic_tex_exists;\n"
"    bool roughness_tex_exists;\n"
"    bool ao_tex_exists;\n"
"};\n"
"struct Light {\n"
"    vec3 position;\n"
"    vec3 direction;\n"
"    vec3 color;\n"
"    bool directional;\n"
"};\n"
"struct Fog {\n"
"    vec3 color;\n"
"    float near;\n"
"    float far;\n"
"};\n"
"in vec2 uv0;\n"
"in vec3 wpos;\n"
"in vec3 norm;\n"
"uniform vec3 camera_position;\n"
"uniform Material material;\n"
"uniform Light light;\n"
"uniform Fog fog;\n"
"float lin_depth(float depth) {\n"
"    float z = depth*2.0-1.0;\n"
"    return (2.0*fog.near*fog.far)/(fog.far+fog.near-z*(fog.far-fog.near));\n"
"}\n"
"const float pi = 3.14159265359;\n"
"vec3 fres(float cos_t, vec3 f0) {\n"
"    return f0+(1.0-f0)*pow(clamp(1.0-cos_t,0.0,1.0),5.0);\n"
"}\n"
"float dist_ggx(vec3 n, vec3 h, float roughness) {\n"
"    float a = roughness*roughness;\n"
"    float a2 = a*a;\n"
"    float ndoth = max(dot(n,h),0.0);\n"
"    float ndoth2 = ndoth*ndoth;\n"
"    float num=a2;\n"
"    float denom=(ndoth2*(a2-1.0)+1.0);\n"
"    denom=pi*denom*denom;\n"
"    return num/denom;\n"
"}\n"
"float geom_sch_ggx(float ndotv, float roughness) {\n"
"    float r = (roughness+1.0);\n"
"    float k = (r*r)/8.0;\n"
"    float num = ndotv;\n"
"    float denom = ndotv*(1.0-k)+k;\n"
"    return num/denom;\n"
"}\n"
"float geom_smith(vec3 n, vec3 v, vec3 l, float roughness) {\n"
"    float ndotv = max(dot(n,v),0.0);\n"
"    float ndotl = max(dot(n,l),0.0);\n"
"    float ggx2 = geom_sch_ggx(ndotv, roughness);\n"
"    float ggx1 = geom_sch_ggx(ndotl, roughness);\n"
"    return ggx1*ggx2;\n"
"}\n"
"void main() {\n"
"    if(texture(material.diffuse_tex, uv0).a < 0.1) discard;\n"
"    vec3 albedo;\n"
"    float metallic;\n"
"    float roughness;\n"
"    float ao;\n"
"    if(material.diffuse_tex_exists) {\n"
"        albedo = pow(texture(material.diffuse_tex, uv0).rgb, vec3(2.2));\n"
"    } else {\n"
"        albedo = material.albedo;\n"
"    }\n"
"    if(material.metallic_tex_exists) {\n"
"        metallic = texture(material.metallic_tex, uv0).r;\n"
"    } else {\n"
"        metallic = material.metallic;\n"
"    }\n"
"    if(material.roughness_tex_exists) {\n"
"        roughness = texture(material.roughness_tex, uv0).r;\n"
"    } else {\n"
"        roughness = material.roughness;\n"
"    }\n"
"    if(material.ao_tex_exists) {\n"
"        ao = texture(material.ao_tex, uv0).r;\n"
"    } else {\n"
"        ao = 1.0f;\n"
"    }\n"
"    vec3 normal;\n"
"    if(material.normal_tex_exists) {\n"
"        vec3 tangent = texture(material.normal_tex, uv0).rgb * 2.0 - 1.0;\n"
"        vec3 q1 = dFdx(wpos);\n"
"        vec3 q2 = dFdy(wpos);\n"
"        vec2 st1 = dFdx(uv0);\n"
"        vec2 st2 = dFdy(uv0);\n"
"        vec3 n = normalize(norm);\n"
"        vec3 t = normalize(q1*st2.t-q2*st1.t);\n"
"        vec3 b = -normalize(cross(n,t));\n"
"        mat3 tbn = mat3(t,b,n);\n"
"        normal = normalize(tbn*tangent);\n"
"    } else {\n"
"        normal = normalize(norm);\n"
"    }\n"
"    vec3 v = normalize(camera_position - wpos);\n"
"    vec3 f0 = vec3(0.04);\n"
"    f0 = mix(f0, albedo, metallic);\n"
"    vec3 lo = vec3(0.0);\n"
"    vec3 l;\n"
"    if(light.directional) {\n"
"        l = normalize(-light.direction);\n"
"    } else {\n"
"        l = normalize(light.position-wpos);\n"
"    }\n"
"    vec3 h = normalize(v+l);\n"
"    float dist;\n"
"    if(light.directional) {\n"
"        dist = length(-light.direction);\n"
"    } else {\n"
"        dist = length(light.position-wpos);\n"
"    }\n"
"    float attent = 1.0/(dist*dist);\n"
"    vec3 rad = light.color*attent;\n"
"    float ndf = dist_ggx(normal,h,roughness);\n"
"    float g = geom_smith(normal,v,l,roughness);\n"
"    vec3 f = fres(max(dot(h,v),0.0),f0);\n"
"    vec3 ks = f;\n"
"    vec3 kd = vec3(1.0)-ks;\n"
"    kd *= 1.0-metallic;\n"
"    vec3 num = ndf*g*f;\n"
"    float denom = 4.0*max(dot(normal,v),0.0)*max(dot(normal,l),0.0)+0.0001;\n"
"    vec3 spec = num/denom;\n"
"    float ndotl = max(dot(normal,l),0.0);\n"
"    lo += (kd*albedo/pi+spec)*rad*ndotl;\n"
"    vec3 ambient = vec3(0.03)*albedo*ao;\n"
"    vec3 color = ambient+lo;\n"
"    color = color/(color+vec3(1.0));\n"
"    color = pow(color, vec3(1.0/2.2));\n"
"    float fog_factor = lin_depth(gl_FragCoord.z)/fog.far;\n"
"    fog_factor = clamp(fog_factor, 0.0, 1.0);\n"
"    out_color = mix(vec4(color,1.0), vec4(fog.color,1.0), fog_factor);\n"
"}\n";
#else
constexpr auto static_shader = "float3x3 inverse(float3x3 m) {\n"
"  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n"
"  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n"
"  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n"
"  float b01 = a22 * a11 - a12 * a21;\n"
"  float b11 = -a22 * a10 + a12 * a20;\n"
"  float b21 = a21 * a10 - a11 * a20;\n"
"  float det = a00 * b01 + a01 * b11 + a02 * b21;\n"
"  return float3x3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n"
"              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n"
"              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n"
"}\n"
"void main(\n"
"        float3 position,\n"
"        float3 __nostrip normal,\n"
"        float2 __nostrip texcoord0,\n"
"        float4 __nostrip joints,\n"
"        float4 __nostrip weights,\n"
"        column_major uniform float4x4 vp,\n"
"        column_major uniform float4x4 model,\n"
"        float4 out gl_Position : POSITION,\n"
"        float2 out uv0 : TEXCOORD0,\n"
"        float3 out wpos : TEXCOORD1,\n"
"        float3 out norm : TEXCOORD2\n"
"        )\n"
"{\n"
"    uv0 = texcoord0;\n"
"    wpos = float3(mul(model, float4(position, 1.0f)));\n"
"    norm = mul(transpose(inverse(float3x3(model))), normal);\n"
"    gl_Position = mul(vp, float4(wpos, 1.0f));\n"
"}\n";
constexpr auto skinned_shader = "float3x3 inverse(float3x3 m) {\n"
"  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2];\n"
"  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2];\n"
"  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2];\n"
"  float b01 = a22 * a11 - a12 * a21;\n"
"  float b11 = -a22 * a10 + a12 * a20;\n"
"  float b21 = a21 * a10 - a11 * a20;\n"
"  float det = a00 * b01 + a01 * b11 + a02 * b21;\n"
"  return float3x3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n"
"              b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n"
"              b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n"
"}\n"
"float4x4 scale(float4x4 m, float s) {\n"
"  float a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3];\n"
"  float a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3];\n"
"  float a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3];\n"
"  float a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3];\n"
"  return float4x4(a00*s, a01*s, a02*s, a03*s,\n"
"          a10*s, a11*s, a12*s, a13*s,\n"
"          a20*s, a21*s, a22*s, a23*s,\n"
"          a30*s, a31*s, a32*s, a33*s);\n"
"}\n"
"void main(\n"
"        float3 position,\n"
"        float3 __nostrip normal,\n"
"        float2 __nostrip texcoord0,\n"
"        float4 __nostrip joints,\n"
"        float4 __nostrip weights,\n"
"        column_major uniform float4x4 vp,\n"
"        column_major uniform float4x4 model,\n"
"        column_major uniform float4x4 pose[100],\n"
"        float4 out gl_Position : POSITION,\n"
"        float2 out uv0 : TEXCOORD0,\n"
"        float3 out wpos : TEXCOORD1,\n"
"        float3 out norm : TEXCOORD2)\n"
"{\n"
"    float4x4 skin = scale(pose[(int)(joints.x)], weights.x) +\n"
"        scale(pose[(int)(joints.y)], weights.y) +\n"
"        scale(pose[(int)(joints.z)], weights.z) +\n"
"        scale(pose[(int)(joints.w)], weights.w);\n"
"    wpos = float3(mul(model, float4(position, 1.0f)));\n"
"    uv0 = texcoord0;\n"
"    norm = mul(transpose(inverse(float3x3(model))), normal);\n"
"    gl_Position = mul(vp, mul(skin, float4(wpos, 1.0f)));\n"
"}\n";
constexpr auto phong_shader = "struct Material {\n"
"    float3 ambient;\n"
"    float3 diffuse;\n"
"    float3 specular;\n"
"    float shininess;\n"
"    sampler2D diffuse_tex;\n"
"    sampler2D normal_tex;\n"
"    sampler2D specular_tex;\n"
"    bool diffuse_tex_exists;\n"
"    bool normal_tex_exists;\n"
"    bool specular_tex_exists;\n"
"};\n"
"struct Light {\n"
"    float3 position;\n"
"    float3 direction;\n"
"    float3 ambient;\n"
"    float3 diffuse;\n"
"    float3 specular;\n"
"    bool directional;\n"
"    float linear;\n"
"    float quadratic;\n"
"};\n"
"struct Fog {\n"
"    float3 color;\n"
"    float near;\n"
"    float far;\n"
"};\n"
"float lin_depth(Fog fog, float depth) {\n"
"    float z = depth*2.0f-1.0f;\n"
"    return (2.0f*fog.near*fog.far)/(fog.far+fog.near-z*(fog.far-fog.near));\n"
"}\n"
"float4 main(\n"
"        float2 uv0 : TEXCOORD0,\n"
"        float3 wpos : TEXCOORD1,\n"
"        float3 norm : TEXCOORD2,\n"
"        uniform float3 camera_position,\n"
"        uniform Material material,\n"
"        uniform Light light,\n"
"        uniform Fog fog,\n"
"        varying in float4 gl_FragCoord : WPOS\n"
"        )\n"
"{\n"
"    if(material.diffuse_tex_exists) {\n"
"        if(tex2D(material.diffuse_tex, uv0).a < 0.1) discard;\n"
"    }\n"
"    float3 ambient;\n"
"    if(material.diffuse_tex_exists) {\n"
"        ambient = light.ambient * tex2D(material.diffuse_tex, uv0).rgb;\n"
"    } else {\n"
"        ambient = light.ambient * material.ambient;\n"
"    }\n"
"    float3 normal = normalize(norm);\n"
"    float3 light_dir;\n"
"    if(light.directional) {\n"
"        light_dir = normalize(-light.direction);\n"
"    } else {\n"
"        light_dir = normalize(light.position-wpos);\n"
"    }\n"
"    float diff = max(dot(normal, light_dir), 0.0f);\n"
"    float3 diffuse;\n"
"    if(material.diffuse_tex_exists) {\n"
"        diffuse = light.diffuse * diff * tex2D(material.diffuse_tex, uv0).rgb;\n"
"    } else {\n"
"        diffuse = light.diffuse * (diff * material.diffuse);\n"
"    }\n"
"    float3 view_dir = normalize(camera_position - wpos);\n"
"    float3 reflect_dir = reflect(-light_dir, normal);\n"
"    float spec;\n"
"    if(material.shininess > 0) {\n"
"        spec = pow(max(dot(view_dir, reflect_dir), 0.0f), material.shininess);\n"
"    } else {\n"
"        spec = pow(max(dot(view_dir, reflect_dir), 0.0f), 0);\n"
"    }\n"
"    float3 specular;\n"
"    if(material.specular_tex_exists) {\n"
"        specular = light.specular * spec * tex2D(material.specular_tex, uv0).rgb;\n"
"    } else if(material.diffuse_tex_exists) {\n"
"        specular = light.specular * spec * tex2D(material.diffuse_tex, uv0).rgb;\n"
"    } else {\n"
"        specular = light.specular * (spec * material.specular);\n"
"    }\n"
"    if(!light.directional) {\n"
"        float dist = length(light.position-wpos);\n"
"        float attent = 1.0f/(1.0f+light.linear*dist+light.quadratic*(dist*dist));\n"
"        ambient *= attent;\n"
"        diffuse *= attent;\n"
"        specular *= attent;\n"
"    }\n"
"    float3 result = ambient + diffuse + specular;\n"
"    float fog_factor = lin_depth(fog, gl_FragCoord.z)/fog.far;\n"
"    fog_factor = clamp(fog_factor, 0.0f, 1.0f);\n"
"    float4 color = lerp(float4(result, 1.0f), float4(fog.color, 1.0f), fog_factor);\n"
"    return color;\n"
"}\n";
constexpr auto pbr_shader = "struct Material {\n"
"    float3 albedo;\n"
"    float metallic;\n"
"    float roughness;\n"
"    sampler2D diffuse_tex;\n"
"    sampler2D normal_tex;\n"
"    sampler2D metallic_tex;\n"
"    sampler2D roughness_tex;\n"
"    sampler2D ao_tex;\n"
"    bool diffuse_tex_exists;\n"
"    bool normal_tex_exists;\n"
"    bool metallic_tex_exists;\n"
"    bool roughness_tex_exists;\n"
"    bool ao_tex_exists;\n"
"};\n"
"struct Light {\n"
"    float3 position;\n"
"    float3 direction;\n"
"    float3 color;\n"
"    bool directional;\n"
"};\n"
"struct Fog {\n"
"    float3 color;\n"
"    float near;\n"
"    float far;\n"
"};\n"
"float lin_depth(Fog fog, float depth) {\n"
"    float z = depth*2.0f-1.0f;\n"
"    return (2.0f*fog.near*fog.far)/(fog.far+fog.near-z*(fog.far-fog.near));\n"
"}\n"
"static const float pi = 3.14159265359;\n"
"float3 fres(float cos_t, float3 f0) {\n"
"    return f0+(1.0f-f0)*pow(clamp(1.0f-cos_t,0.0f,1.0f),5.0f);\n"
"}\n"
"float dist_ggx(float3 n, float3 h, float roughness) {\n"
"    float a = roughness*roughness;\n"
"    float a2 = a*a;\n"
"    float ndoth = max(dot(n,h),0.0f);\n"
"    float ndoth2 = ndoth*ndoth;\n"
"    float num = a2;\n"
"    float denom = (ndoth2*(a2-1.0f)+1.0f);\n"
"    denom = pi*denom*denom;\n"
"    return num/denom;\n"
"}\n"
"float geom_sch_ggx(float ndotv, float roughness) {\n"
"    float r = (roughness+1.0f);\n"
"    float k = (r*r)/8.0f;\n"
"    float num = ndotv;\n"
"    float denom = ndotv*(1.0f-k)+k;\n"
"    return num/denom;\n"
"}\n"
"float geom_smith(float3 n, float3 v, float3 l, float roughness) {\n"
"    float ndotv = max(dot(n,v),0.0f);\n"
"    float ndotl = max(dot(n,l),0.0f);\n"
"    float ggx2 = geom_sch_ggx(ndotv, roughness);\n"
"    float ggx1 = geom_sch_ggx(ndotl, roughness);\n"
"    return ggx1*ggx2;\n"
"}\n"
"float4 main(\n"
"        float2 uv0 : TEXCOORD0,\n"
"        float3 wpos : TEXCOORD1,\n"
"        float3 norm : TEXCOORD2,\n"
"        uniform float3 camera_position,\n"
"        uniform Material material,\n"
"        uniform Light light,\n"
"        uniform Fog fog,\n"
"        varying in float4 gl_FragCoord : WPOS\n"
"        )\n"
"{\n"
"    if(tex2D(material.diffuse_tex, uv0).a < 0.1) discard;\n"
"    float3 albedo;\n"
"    float metallic;\n"
"    float roughness;\n"
"    float ao;\n"
"    if(material.diffuse_tex_exists) {\n"
"        albedo = pow(tex2D(material.diffuse_tex, uv0).rgb, float3(2.2f, 2.2f, 2.2f));\n"
"    } else {\n"
"        albedo = material.albedo;\n"
"    }\n"
"    if(material.metallic_tex_exists) {\n"
"        metallic = tex2D(material.metallic_tex, uv0).r;\n"
"    } else {\n"
"        metallic = material.metallic;\n"
"    }\n"
"    if(material.roughness_tex_exists) {\n"
"        roughness = tex2D(material.roughness_tex, uv0).r;\n"
"    } else {\n"
"        roughness = material.roughness;\n"
"    }\n"
"    if(material.ao_tex_exists) {\n"
"        ao = tex2D(material.ao_tex, uv0).r;\n"
"    } else {\n"
"        ao = 1.0f;\n"
"    }\n"
"    float3 normal = normalize(norm);\n"
"    float3 v = normalize(camera_position-wpos);\n"
"    float3 f0 = float3(0.04f, 0.04f, 0.04f);\n"
"    f0 = lerp(f0, albedo, metallic);\n"
"    float3 lo = float3(0.0f, 0.0f, 0.0f);\n"
"    float3 l;\n"
"    if(light.directional) {\n"
"        l = normalize(-light.direction);\n"
"    } else {\n"
"        l = normalize(light.position-wpos);\n"
"    }\n"
"    float3 h = normalize(v+l);\n"
"    float dist;\n"
"    if(light.directional) {\n"
"        dist = length(-light.direction);\n"
"    } else {\n"
"        dist = length(light.position-wpos);\n"
"    }\n"
"    float attent = 1.0f/(dist*dist);\n"
"    float3 rad = light.color*attent;\n"
"    float ndf = dist_ggx(normal,h,roughness);\n"
"    float g = geom_smith(normal,v,l,roughness);\n"
"    float3 f = fres(max(dot(h,v),0.0f),f0);\n"
"    float3 ks = f;\n"
"    float3 kd = float3(1.0f, 1.0f, 1.0f)-ks;\n"
"    kd *= 1.0f-metallic;\n"
"    float3 num = ndf*g*f;\n"
"    float denom = 4.0f*max(dot(normal,v),0.0f)*max(dot(normal,l),0.0f)+0.0001f;\n"
"    float3 spec = num/denom;\n"
"    float ndotl = max(dot(normal,l),0.0f);\n"
"    lo += (kd*albedo/pi+spec)*rad*ndotl;\n"
"    float3 ambient = float3(0.03f, 0.03f, 0.03f)*albedo*ao;\n"
"    float3 color = ambient+lo;\n"
"    color = color/(color+float3(1.0f, 1.0f, 1.0f));\n"
"    color = pow(color, float3(1.0f/2.2f, 1.0f/2.2f, 1.0f/2.2f));\n"
"    float fog_factor = lin_depth(fog, gl_FragCoord.z)/fog.far;\n"
"    fog_factor = clamp(fog_factor, 0.0f, 1.0f);\n"
"    float4 out_color = lerp(float4(color, 1.0f), float4(fog.color, 1.0f), fog_factor);\n"
"    return out_color;\n"
"}\n";
#endif

inline std::pair<Shader*, ShadingType> make_static_phong() { return std::make_pair(new Shader{static_shader, phong_shader, false}, ShadingType::PHONG); }
inline std::pair<Shader*, ShadingType> make_static_pbr() { return std::make_pair(new Shader{static_shader, pbr_shader, false}, ShadingType::PBR); }
inline std::pair<Shader*, ShadingType> make_skinned_phong() { return std::make_pair(new Shader{skinned_shader, phong_shader, false}, ShadingType::PHONG); }
inline std::pair<Shader*, ShadingType> make_skinned_pbr() { return std::make_pair(new Shader{skinned_shader, pbr_shader, false}, ShadingType::PBR); }

}

}
