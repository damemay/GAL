// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesh.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mesh_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_mesh_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4024000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4024004 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_mesh_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_mesh_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_mesh_2eproto;
namespace glp_util {
class Mesh;
struct MeshDefaultTypeInternal;
extern MeshDefaultTypeInternal _Mesh_default_instance_;
class Mesh_Vec2;
struct Mesh_Vec2DefaultTypeInternal;
extern Mesh_Vec2DefaultTypeInternal _Mesh_Vec2_default_instance_;
class Mesh_Vec3;
struct Mesh_Vec3DefaultTypeInternal;
extern Mesh_Vec3DefaultTypeInternal _Mesh_Vec3_default_instance_;
class Mesh_Vertex;
struct Mesh_VertexDefaultTypeInternal;
extern Mesh_VertexDefaultTypeInternal _Mesh_Vertex_default_instance_;
}  // namespace glp_util
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace glp_util {

// ===================================================================


// -------------------------------------------------------------------

class Mesh_Vec3 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:glp_util.Mesh.Vec3) */ {
 public:
  inline Mesh_Vec3() : Mesh_Vec3(nullptr) {}
  ~Mesh_Vec3() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Mesh_Vec3(::google::protobuf::internal::ConstantInitialized);

  Mesh_Vec3(const Mesh_Vec3& from);
  Mesh_Vec3(Mesh_Vec3&& from) noexcept
    : Mesh_Vec3() {
    *this = ::std::move(from);
  }

  inline Mesh_Vec3& operator=(const Mesh_Vec3& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mesh_Vec3& operator=(Mesh_Vec3&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mesh_Vec3& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mesh_Vec3* internal_default_instance() {
    return reinterpret_cast<const Mesh_Vec3*>(
               &_Mesh_Vec3_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Mesh_Vec3& a, Mesh_Vec3& b) {
    a.Swap(&b);
  }
  inline void Swap(Mesh_Vec3* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mesh_Vec3* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mesh_Vec3* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mesh_Vec3>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Mesh_Vec3& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Mesh_Vec3& from) {
    Mesh_Vec3::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mesh_Vec3* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "glp_util.Mesh.Vec3";
  }
  protected:
  explicit Mesh_Vec3(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // required float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 2;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // required float z = 3;
  bool has_z() const;
  void clear_z() ;
  float z() const;
  void set_z(float value);

  private:
  float _internal_z() const;
  void _internal_set_z(float value);

  public:
  // @@protoc_insertion_point(class_scope:glp_util.Mesh.Vec3)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float z_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mesh_2eproto;
};// -------------------------------------------------------------------

class Mesh_Vec2 final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:glp_util.Mesh.Vec2) */ {
 public:
  inline Mesh_Vec2() : Mesh_Vec2(nullptr) {}
  ~Mesh_Vec2() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Mesh_Vec2(::google::protobuf::internal::ConstantInitialized);

  Mesh_Vec2(const Mesh_Vec2& from);
  Mesh_Vec2(Mesh_Vec2&& from) noexcept
    : Mesh_Vec2() {
    *this = ::std::move(from);
  }

  inline Mesh_Vec2& operator=(const Mesh_Vec2& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mesh_Vec2& operator=(Mesh_Vec2&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mesh_Vec2& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mesh_Vec2* internal_default_instance() {
    return reinterpret_cast<const Mesh_Vec2*>(
               &_Mesh_Vec2_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Mesh_Vec2& a, Mesh_Vec2& b) {
    a.Swap(&b);
  }
  inline void Swap(Mesh_Vec2* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mesh_Vec2* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mesh_Vec2* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mesh_Vec2>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Mesh_Vec2& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Mesh_Vec2& from) {
    Mesh_Vec2::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mesh_Vec2* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "glp_util.Mesh.Vec2";
  }
  protected:
  explicit Mesh_Vec2(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // required float x = 1;
  bool has_x() const;
  void clear_x() ;
  float x() const;
  void set_x(float value);

  private:
  float _internal_x() const;
  void _internal_set_x(float value);

  public:
  // required float y = 2;
  bool has_y() const;
  void clear_y() ;
  float y() const;
  void set_y(float value);

  private:
  float _internal_y() const;
  void _internal_set_y(float value);

  public:
  // @@protoc_insertion_point(class_scope:glp_util.Mesh.Vec2)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mesh_2eproto;
};// -------------------------------------------------------------------

class Mesh_Vertex final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:glp_util.Mesh.Vertex) */ {
 public:
  inline Mesh_Vertex() : Mesh_Vertex(nullptr) {}
  ~Mesh_Vertex() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Mesh_Vertex(::google::protobuf::internal::ConstantInitialized);

  Mesh_Vertex(const Mesh_Vertex& from);
  Mesh_Vertex(Mesh_Vertex&& from) noexcept
    : Mesh_Vertex() {
    *this = ::std::move(from);
  }

  inline Mesh_Vertex& operator=(const Mesh_Vertex& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mesh_Vertex& operator=(Mesh_Vertex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mesh_Vertex& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mesh_Vertex* internal_default_instance() {
    return reinterpret_cast<const Mesh_Vertex*>(
               &_Mesh_Vertex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Mesh_Vertex& a, Mesh_Vertex& b) {
    a.Swap(&b);
  }
  inline void Swap(Mesh_Vertex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mesh_Vertex* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mesh_Vertex* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mesh_Vertex>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Mesh_Vertex& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Mesh_Vertex& from) {
    Mesh_Vertex::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mesh_Vertex* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "glp_util.Mesh.Vertex";
  }
  protected:
  explicit Mesh_Vertex(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPositionFieldNumber = 1,
    kNormalFieldNumber = 2,
    kUvFieldNumber = 3,
  };
  // required .glp_util.Mesh.Vec3 position = 1;
  bool has_position() const;
  void clear_position() ;
  const ::glp_util::Mesh_Vec3& position() const;
  PROTOBUF_NODISCARD ::glp_util::Mesh_Vec3* release_position();
  ::glp_util::Mesh_Vec3* mutable_position();
  void set_allocated_position(::glp_util::Mesh_Vec3* value);
  void unsafe_arena_set_allocated_position(::glp_util::Mesh_Vec3* value);
  ::glp_util::Mesh_Vec3* unsafe_arena_release_position();

  private:
  const ::glp_util::Mesh_Vec3& _internal_position() const;
  ::glp_util::Mesh_Vec3* _internal_mutable_position();

  public:
  // required .glp_util.Mesh.Vec3 normal = 2;
  bool has_normal() const;
  void clear_normal() ;
  const ::glp_util::Mesh_Vec3& normal() const;
  PROTOBUF_NODISCARD ::glp_util::Mesh_Vec3* release_normal();
  ::glp_util::Mesh_Vec3* mutable_normal();
  void set_allocated_normal(::glp_util::Mesh_Vec3* value);
  void unsafe_arena_set_allocated_normal(::glp_util::Mesh_Vec3* value);
  ::glp_util::Mesh_Vec3* unsafe_arena_release_normal();

  private:
  const ::glp_util::Mesh_Vec3& _internal_normal() const;
  ::glp_util::Mesh_Vec3* _internal_mutable_normal();

  public:
  // required .glp_util.Mesh.Vec2 uv = 3;
  bool has_uv() const;
  void clear_uv() ;
  const ::glp_util::Mesh_Vec2& uv() const;
  PROTOBUF_NODISCARD ::glp_util::Mesh_Vec2* release_uv();
  ::glp_util::Mesh_Vec2* mutable_uv();
  void set_allocated_uv(::glp_util::Mesh_Vec2* value);
  void unsafe_arena_set_allocated_uv(::glp_util::Mesh_Vec2* value);
  ::glp_util::Mesh_Vec2* unsafe_arena_release_uv();

  private:
  const ::glp_util::Mesh_Vec2& _internal_uv() const;
  ::glp_util::Mesh_Vec2* _internal_mutable_uv();

  public:
  // @@protoc_insertion_point(class_scope:glp_util.Mesh.Vertex)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 3, 0, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::glp_util::Mesh_Vec3* position_;
    ::glp_util::Mesh_Vec3* normal_;
    ::glp_util::Mesh_Vec2* uv_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mesh_2eproto;
};// -------------------------------------------------------------------

class Mesh final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:glp_util.Mesh) */ {
 public:
  inline Mesh() : Mesh(nullptr) {}
  ~Mesh() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Mesh(::google::protobuf::internal::ConstantInitialized);

  Mesh(const Mesh& from);
  Mesh(Mesh&& from) noexcept
    : Mesh() {
    *this = ::std::move(from);
  }

  inline Mesh& operator=(const Mesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline Mesh& operator=(Mesh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Mesh& default_instance() {
    return *internal_default_instance();
  }
  static inline const Mesh* internal_default_instance() {
    return reinterpret_cast<const Mesh*>(
               &_Mesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Mesh& a, Mesh& b) {
    a.Swap(&b);
  }
  inline void Swap(Mesh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Mesh* other) {
    if (other == this) return;
    ABSL_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Mesh* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Mesh>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Mesh& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Mesh& from) {
    Mesh::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Mesh* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "glp_util.Mesh";
  }
  protected:
  explicit Mesh(::google::protobuf::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Mesh_Vec3 Vec3;
  typedef Mesh_Vec2 Vec2;
  typedef Mesh_Vertex Vertex;

  // accessors -------------------------------------------------------

  enum : int {
    kVerticesFieldNumber = 1,
    kIndicesFieldNumber = 2,
    kTexturesFieldNumber = 3,
  };
  // repeated .glp_util.Mesh.Vertex vertices = 1;
  int vertices_size() const;
  private:
  int _internal_vertices_size() const;

  public:
  void clear_vertices() ;
  ::glp_util::Mesh_Vertex* mutable_vertices(int index);
  ::google::protobuf::RepeatedPtrField< ::glp_util::Mesh_Vertex >*
      mutable_vertices();
  private:
  const ::google::protobuf::RepeatedPtrField<::glp_util::Mesh_Vertex>& _internal_vertices() const;
  ::google::protobuf::RepeatedPtrField<::glp_util::Mesh_Vertex>* _internal_mutable_vertices();
  public:
  const ::glp_util::Mesh_Vertex& vertices(int index) const;
  ::glp_util::Mesh_Vertex* add_vertices();
  const ::google::protobuf::RepeatedPtrField< ::glp_util::Mesh_Vertex >&
      vertices() const;
  // repeated uint32 indices = 2;
  int indices_size() const;
  private:
  int _internal_indices_size() const;

  public:
  void clear_indices() ;
  ::uint32_t indices(int index) const;
  void set_indices(int index, ::uint32_t value);
  void add_indices(::uint32_t value);
  const ::google::protobuf::RepeatedField<::uint32_t>& indices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* mutable_indices();

  private:
  const ::google::protobuf::RepeatedField<::uint32_t>& _internal_indices() const;
  ::google::protobuf::RepeatedField<::uint32_t>* _internal_mutable_indices();

  public:
  // repeated string textures = 3;
  int textures_size() const;
  private:
  int _internal_textures_size() const;

  public:
  void clear_textures() ;
  const std::string& textures(int index) const;
  std::string* mutable_textures(int index);
  void set_textures(int index, const std::string& value);
  void set_textures(int index, std::string&& value);
  void set_textures(int index, const char* value);
  void set_textures(int index, const char* value, std::size_t size);
  void set_textures(int index, absl::string_view value);
  std::string* add_textures();
  void add_textures(const std::string& value);
  void add_textures(std::string&& value);
  void add_textures(const char* value);
  void add_textures(const char* value, std::size_t size);
  void add_textures(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& textures() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_textures();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_textures() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_textures();

  public:
  // @@protoc_insertion_point(class_scope:glp_util.Mesh)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<2, 3, 1, 30, 2> _table_;
  template <typename T> friend class ::google::protobuf::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::google::protobuf::RepeatedPtrField< ::glp_util::Mesh_Vertex > vertices_;
    ::google::protobuf::RepeatedField<::uint32_t> indices_;
    ::google::protobuf::RepeatedPtrField<std::string> textures_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_mesh_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Mesh_Vec3

// required float x = 1;
inline bool Mesh_Vec3::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Mesh_Vec3::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Mesh_Vec3::x() const {
  // @@protoc_insertion_point(field_get:glp_util.Mesh.Vec3.x)
  return _internal_x();
}
inline void Mesh_Vec3::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:glp_util.Mesh.Vec3.x)
}
inline float Mesh_Vec3::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Mesh_Vec3::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// required float y = 2;
inline bool Mesh_Vec3::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Mesh_Vec3::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Mesh_Vec3::y() const {
  // @@protoc_insertion_point(field_get:glp_util.Mesh.Vec3.y)
  return _internal_y();
}
inline void Mesh_Vec3::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:glp_util.Mesh.Vec3.y)
}
inline float Mesh_Vec3::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Mesh_Vec3::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// required float z = 3;
inline bool Mesh_Vec3::has_z() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline void Mesh_Vec3::clear_z() {
  _impl_.z_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Mesh_Vec3::z() const {
  // @@protoc_insertion_point(field_get:glp_util.Mesh.Vec3.z)
  return _internal_z();
}
inline void Mesh_Vec3::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:glp_util.Mesh.Vec3.z)
}
inline float Mesh_Vec3::_internal_z() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.z_;
}
inline void Mesh_Vec3::_internal_set_z(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.z_ = value;
}

// -------------------------------------------------------------------

// Mesh_Vec2

// required float x = 1;
inline bool Mesh_Vec2::has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline void Mesh_Vec2::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float Mesh_Vec2::x() const {
  // @@protoc_insertion_point(field_get:glp_util.Mesh.Vec2.x)
  return _internal_x();
}
inline void Mesh_Vec2::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:glp_util.Mesh.Vec2.x)
}
inline float Mesh_Vec2::_internal_x() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.x_;
}
inline void Mesh_Vec2::_internal_set_x(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}

// required float y = 2;
inline bool Mesh_Vec2::has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline void Mesh_Vec2::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Mesh_Vec2::y() const {
  // @@protoc_insertion_point(field_get:glp_util.Mesh.Vec2.y)
  return _internal_y();
}
inline void Mesh_Vec2::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:glp_util.Mesh.Vec2.y)
}
inline float Mesh_Vec2::_internal_y() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.y_;
}
inline void Mesh_Vec2::_internal_set_y(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}

// -------------------------------------------------------------------

// Mesh_Vertex

// required .glp_util.Mesh.Vec3 position = 1;
inline bool Mesh_Vertex::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline void Mesh_Vertex::clear_position() {
  if (_impl_.position_ != nullptr) _impl_.position_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::glp_util::Mesh_Vec3& Mesh_Vertex::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::glp_util::Mesh_Vec3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::glp_util::Mesh_Vec3&>(::glp_util::_Mesh_Vec3_default_instance_);
}
inline const ::glp_util::Mesh_Vec3& Mesh_Vertex::position() const {
  // @@protoc_insertion_point(field_get:glp_util.Mesh.Vertex.position)
  return _internal_position();
}
inline void Mesh_Vertex::unsafe_arena_set_allocated_position(::glp_util::Mesh_Vec3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::glp_util::Mesh_Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:glp_util.Mesh.Vertex.position)
}
inline ::glp_util::Mesh_Vec3* Mesh_Vertex::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::glp_util::Mesh_Vec3* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::glp_util::Mesh_Vec3* Mesh_Vertex::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:glp_util.Mesh.Vertex.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::glp_util::Mesh_Vec3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::glp_util::Mesh_Vec3* Mesh_Vertex::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::glp_util::Mesh_Vec3>(GetArenaForAllocation());
    _impl_.position_ = reinterpret_cast<::glp_util::Mesh_Vec3*>(p);
  }
  return _impl_.position_;
}
inline ::glp_util::Mesh_Vec3* Mesh_Vertex::mutable_position() {
  ::glp_util::Mesh_Vec3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:glp_util.Mesh.Vertex.position)
  return _msg;
}
inline void Mesh_Vertex::set_allocated_position(::glp_util::Mesh_Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::glp_util::Mesh_Vec3*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::glp_util::Mesh_Vec3*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::glp_util::Mesh_Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:glp_util.Mesh.Vertex.position)
}

// required .glp_util.Mesh.Vec3 normal = 2;
inline bool Mesh_Vertex::has_normal() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.normal_ != nullptr);
  return value;
}
inline void Mesh_Vertex::clear_normal() {
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::glp_util::Mesh_Vec3& Mesh_Vertex::_internal_normal() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::glp_util::Mesh_Vec3* p = _impl_.normal_;
  return p != nullptr ? *p : reinterpret_cast<const ::glp_util::Mesh_Vec3&>(::glp_util::_Mesh_Vec3_default_instance_);
}
inline const ::glp_util::Mesh_Vec3& Mesh_Vertex::normal() const {
  // @@protoc_insertion_point(field_get:glp_util.Mesh.Vertex.normal)
  return _internal_normal();
}
inline void Mesh_Vertex::unsafe_arena_set_allocated_normal(::glp_util::Mesh_Vec3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.normal_);
  }
  _impl_.normal_ = reinterpret_cast<::glp_util::Mesh_Vec3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:glp_util.Mesh.Vertex.normal)
}
inline ::glp_util::Mesh_Vec3* Mesh_Vertex::release_normal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::glp_util::Mesh_Vec3* released = _impl_.normal_;
  _impl_.normal_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::glp_util::Mesh_Vec3* Mesh_Vertex::unsafe_arena_release_normal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:glp_util.Mesh.Vertex.normal)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::glp_util::Mesh_Vec3* temp = _impl_.normal_;
  _impl_.normal_ = nullptr;
  return temp;
}
inline ::glp_util::Mesh_Vec3* Mesh_Vertex::_internal_mutable_normal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.normal_ == nullptr) {
    auto* p = CreateMaybeMessage<::glp_util::Mesh_Vec3>(GetArenaForAllocation());
    _impl_.normal_ = reinterpret_cast<::glp_util::Mesh_Vec3*>(p);
  }
  return _impl_.normal_;
}
inline ::glp_util::Mesh_Vec3* Mesh_Vertex::mutable_normal() {
  ::glp_util::Mesh_Vec3* _msg = _internal_mutable_normal();
  // @@protoc_insertion_point(field_mutable:glp_util.Mesh.Vertex.normal)
  return _msg;
}
inline void Mesh_Vertex::set_allocated_normal(::glp_util::Mesh_Vec3* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::glp_util::Mesh_Vec3*>(_impl_.normal_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::glp_util::Mesh_Vec3*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.normal_ = reinterpret_cast<::glp_util::Mesh_Vec3*>(value);
  // @@protoc_insertion_point(field_set_allocated:glp_util.Mesh.Vertex.normal)
}

// required .glp_util.Mesh.Vec2 uv = 3;
inline bool Mesh_Vertex::has_uv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.uv_ != nullptr);
  return value;
}
inline void Mesh_Vertex::clear_uv() {
  if (_impl_.uv_ != nullptr) _impl_.uv_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::glp_util::Mesh_Vec2& Mesh_Vertex::_internal_uv() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::glp_util::Mesh_Vec2* p = _impl_.uv_;
  return p != nullptr ? *p : reinterpret_cast<const ::glp_util::Mesh_Vec2&>(::glp_util::_Mesh_Vec2_default_instance_);
}
inline const ::glp_util::Mesh_Vec2& Mesh_Vertex::uv() const {
  // @@protoc_insertion_point(field_get:glp_util.Mesh.Vertex.uv)
  return _internal_uv();
}
inline void Mesh_Vertex::unsafe_arena_set_allocated_uv(::glp_util::Mesh_Vec2* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.uv_);
  }
  _impl_.uv_ = reinterpret_cast<::glp_util::Mesh_Vec2*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:glp_util.Mesh.Vertex.uv)
}
inline ::glp_util::Mesh_Vec2* Mesh_Vertex::release_uv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::glp_util::Mesh_Vec2* released = _impl_.uv_;
  _impl_.uv_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArenaForAllocation() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::glp_util::Mesh_Vec2* Mesh_Vertex::unsafe_arena_release_uv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:glp_util.Mesh.Vertex.uv)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::glp_util::Mesh_Vec2* temp = _impl_.uv_;
  _impl_.uv_ = nullptr;
  return temp;
}
inline ::glp_util::Mesh_Vec2* Mesh_Vertex::_internal_mutable_uv() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.uv_ == nullptr) {
    auto* p = CreateMaybeMessage<::glp_util::Mesh_Vec2>(GetArenaForAllocation());
    _impl_.uv_ = reinterpret_cast<::glp_util::Mesh_Vec2*>(p);
  }
  return _impl_.uv_;
}
inline ::glp_util::Mesh_Vec2* Mesh_Vertex::mutable_uv() {
  ::glp_util::Mesh_Vec2* _msg = _internal_mutable_uv();
  // @@protoc_insertion_point(field_mutable:glp_util.Mesh.Vertex.uv)
  return _msg;
}
inline void Mesh_Vertex::set_allocated_uv(::glp_util::Mesh_Vec2* value) {
  ::google::protobuf::Arena* message_arena = GetArenaForAllocation();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::glp_util::Mesh_Vec2*>(_impl_.uv_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena =
        ::google::protobuf::Arena::InternalGetOwningArena(reinterpret_cast<::glp_util::Mesh_Vec2*>(value));
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.uv_ = reinterpret_cast<::glp_util::Mesh_Vec2*>(value);
  // @@protoc_insertion_point(field_set_allocated:glp_util.Mesh.Vertex.uv)
}

// -------------------------------------------------------------------

// Mesh

// repeated .glp_util.Mesh.Vertex vertices = 1;
inline int Mesh::_internal_vertices_size() const {
  return _internal_vertices().size();
}
inline int Mesh::vertices_size() const {
  return _internal_vertices_size();
}
inline void Mesh::clear_vertices() {
  _internal_mutable_vertices()->Clear();
}
inline ::glp_util::Mesh_Vertex* Mesh::mutable_vertices(int index) {
  // @@protoc_insertion_point(field_mutable:glp_util.Mesh.vertices)
  return _internal_mutable_vertices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::glp_util::Mesh_Vertex >*
Mesh::mutable_vertices() {
  // @@protoc_insertion_point(field_mutable_list:glp_util.Mesh.vertices)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_vertices();
}
inline const ::glp_util::Mesh_Vertex& Mesh::vertices(int index) const {
  // @@protoc_insertion_point(field_get:glp_util.Mesh.vertices)
    return _internal_vertices().Get(index);
}
inline ::glp_util::Mesh_Vertex* Mesh::add_vertices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::glp_util::Mesh_Vertex* _add = _internal_mutable_vertices()->Add();
  // @@protoc_insertion_point(field_add:glp_util.Mesh.vertices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField< ::glp_util::Mesh_Vertex >&
Mesh::vertices() const {
  // @@protoc_insertion_point(field_list:glp_util.Mesh.vertices)
  return _internal_vertices();
}
inline const ::google::protobuf::RepeatedPtrField<::glp_util::Mesh_Vertex>&
Mesh::_internal_vertices() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.vertices_;
}
inline ::google::protobuf::RepeatedPtrField<::glp_util::Mesh_Vertex>*
Mesh::_internal_mutable_vertices() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.vertices_;
}

// repeated uint32 indices = 2;
inline int Mesh::_internal_indices_size() const {
  return _internal_indices().size();
}
inline int Mesh::indices_size() const {
  return _internal_indices_size();
}
inline void Mesh::clear_indices() {
  _internal_mutable_indices()->Clear();
}
inline ::uint32_t Mesh::indices(int index) const {
  // @@protoc_insertion_point(field_get:glp_util.Mesh.indices)
  return _internal_indices().Get(index);
}
inline void Mesh::set_indices(int index, ::uint32_t value) {
  _internal_mutable_indices()->Set(index, value);
  // @@protoc_insertion_point(field_set:glp_util.Mesh.indices)
}
inline void Mesh::add_indices(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_indices()->Add(value);
  // @@protoc_insertion_point(field_add:glp_util.Mesh.indices)
}
inline const ::google::protobuf::RepeatedField<::uint32_t>& Mesh::indices() const {
  // @@protoc_insertion_point(field_list:glp_util.Mesh.indices)
  return _internal_indices();
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Mesh::mutable_indices() {
  // @@protoc_insertion_point(field_mutable_list:glp_util.Mesh.indices)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_indices();
}

inline const ::google::protobuf::RepeatedField<::uint32_t>& Mesh::_internal_indices() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.indices_;
}
inline ::google::protobuf::RepeatedField<::uint32_t>* Mesh::_internal_mutable_indices() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.indices_;
}

// repeated string textures = 3;
inline int Mesh::_internal_textures_size() const {
  return _internal_textures().size();
}
inline int Mesh::textures_size() const {
  return _internal_textures_size();
}
inline void Mesh::clear_textures() {
  _internal_mutable_textures()->Clear();
}
inline std::string* Mesh::add_textures() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_textures()->Add();
  // @@protoc_insertion_point(field_add_mutable:glp_util.Mesh.textures)
  return _s;
}
inline const std::string& Mesh::textures(int index) const {
  // @@protoc_insertion_point(field_get:glp_util.Mesh.textures)
  return _internal_textures().Get(index);
}
inline std::string* Mesh::mutable_textures(int index) {
  // @@protoc_insertion_point(field_mutable:glp_util.Mesh.textures)
  return _internal_mutable_textures()->Mutable(index);
}
inline void Mesh::set_textures(int index, const std::string& value) {
  _internal_mutable_textures()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:glp_util.Mesh.textures)
}
inline void Mesh::set_textures(int index, std::string&& value) {
  _internal_mutable_textures()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:glp_util.Mesh.textures)
}
inline void Mesh::set_textures(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_textures()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:glp_util.Mesh.textures)
}
inline void Mesh::set_textures(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_textures()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:glp_util.Mesh.textures)
}
inline void Mesh::set_textures(int index, absl::string_view value) {
  _internal_mutable_textures()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:glp_util.Mesh.textures)
}
inline void Mesh::add_textures(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_textures()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:glp_util.Mesh.textures)
}
inline void Mesh::add_textures(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_textures()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:glp_util.Mesh.textures)
}
inline void Mesh::add_textures(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_textures()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:glp_util.Mesh.textures)
}
inline void Mesh::add_textures(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_textures()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:glp_util.Mesh.textures)
}
inline void Mesh::add_textures(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_textures()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:glp_util.Mesh.textures)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Mesh::textures() const {
  // @@protoc_insertion_point(field_list:glp_util.Mesh.textures)
  return _internal_textures();
}
inline ::google::protobuf::RepeatedPtrField<std::string>* Mesh::mutable_textures() {
  // @@protoc_insertion_point(field_mutable_list:glp_util.Mesh.textures)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_textures();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Mesh::_internal_textures() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.textures_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Mesh::_internal_mutable_textures() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.textures_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace glp_util


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_mesh_2eproto_2epb_2eh
